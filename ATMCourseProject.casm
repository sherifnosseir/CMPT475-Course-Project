CoreASM ATM_System

use Standard
use Math
use QueuePlugin

universe ATM = {TillControl, CentralNetwork, CentralDatabase}
universe Till = {Till1, Till2, Till3}
universe Client = { Client1, Client2, Client3}

universe Agents = {ATM_Controller1, ATM_Controller2, ATM_Controller3, Network_Controller, user1, user2, user3, observer}

enum TillStatus = { Available, InUse, BeginProcessing, Processing }
enum AccountStatus = { LoggedIn, LoggedOut, AccountLocked }
enum UserOperation = { EnterPIN,CheckBalance, Withdraw, RequestStatement, LogOut, Standby}
enum UserInput = { NoInput, CorrectPIN, IncorrectPIN}
enum DataReturn = { NoData, Unsuccessful, Successful, Report }

function tillStatus: Till -> TillStatus
function accountStatus: Client-> AccountStatus
function clientAction: Client -> UserOperation
function userInput : Client -> UserInput
function selectTill: Client -> Till
function selectClient: program -> Client
function returnData: Till -> DataReturn

// Variables
function controlled INqueue: till -> LIST
function controlled OUTqueue: till -> LIST

init Main

rule Main = {
        forall t in Till do{
                tillStatus(t) := Available
                returnData(t) := NoData
        }
        forall c in Client do{
                clientAction(c) := LogOut
                accountStatus(c) := LoggedOut
                userInput(c) := NoInput
        }
        inQueueStatus := unlocked
        outQueueStatus := unlocked
        
        selectTill(Client1) := Till1
        selectTill(Client2) := Till2
        selectTill(Client3) := Till3
        
        selectClient(ATM_Controller1) := Client1
        selectClient(ATM_Controller2) := Client2
        selectClient(ATM_Controller3) := Client3
        
        selectClient(user1) := Client1
        selectClient(user2) := Client2
        selectClient(user3) := Client3

        INqueue(Till1):=[]
        INqueue(Till2):=[]
        INqueue(Till3):=[]
        OUTqueue(Till1):=[]
        OUTqueue(Till2):=[]
        OUTqueue(Till3):=[]

		seqblock
        program(self) := undef
        program(ATM_Controller1) := @ATMController
        program(ATM_Controller2) := @ATMController
        program(ATM_Controller3) := @ATMController
        program(Network_Controller) := @NetworkController
        program(user1) := @UserBehaviour
        program(user2) := @UserBehaviour
        program(user3) := @UserBehaviour
        program(observer) := @Observer
		endseqblock
}

rule RandomVal =
        return rnd in
        choose x in [1 .. 100] do
                rnd := x/100

rule ATMController =
par 
seqblock
		c := selectClient(self)
		t := selectTill(c)
endseqblock
		
		par
                if clientAction(c) = EnterPIN then seqblock
                        if userInput(c) = CorrectPIN then seqblock
                                accountStatus(c) := LoggedIn
                        endseqblock
                endseqblock

                if(clientAction(c) = LogOut) then seqblock
                        tillStatus(t) := Available
                        accountStatus(c) := LoggedOut
                        returnData(t) := NoData
                endseqblock
                else if (accountStatus(c) = LoggedIn and tillStatus(t) = Available) then seqblock
                        tillStatus(t) := InUse
                endseqblock
                else if (accountStatus(c) = LoggedIn and tillStatus(t) = BeginProcessing) then seqblock
                        print "***************"+t
                        print "_+_+_+_+_+_+_+_"+clientAction(c)
                        PushToInQueue(t, [t, clientAction(c)])
                        print size(INqueue(t))
                        tillStatus(t):= Processing
                endseqblock

                if (returnData(t)!=NoData) then seqblock
                        print "@@@ " + t + " Result @@@: " + returnData(t)
                        tillStatus(t):= InUse
                        returnData(t) := NoData
                endseqblock
	endpar
endpar

rule NetworkController = {
	forall t in Till do {
        if (size(INqueue(t)) > 0) then seqblock
        		print "Pushing to DB"
                dequeue nextdbOp from INqueue(t)
                PassToDatabase(head(nextdbOp), head(tail(nextdbOp)))
        endseqblock

        if (size(OUTqueue(t)) > 0) then seqblock
        		print "Pushing to Till"
                dequeue nextTillOp from OUTqueue(t)
                PassToTill(head(nextTillOp), head(tail(nextTillOp)))
        endseqblock
    }
}

rule PushToInQueue(t, x) =
par
	print "Pushing to network IN"
	add x to INqueue(t)
endpar

rule PushToOutQueue(t, x) =
par
	print "Pushing to network OUT"
	add x to OUTqueue(t)
endpar

rule PassToDatabase(till, action) = par
        if (action = Withdraw) then seqblock
                if RandomVal > 0.7 then seqblock
                        PushToOutQueue(till, [till, "Successful"])
                endseqblock
                else seqblock
                        PushToOutQueue(till, [till, "Unsuccessful"])
                endseqblock
        endseqblock
        else if(action = RequestStatement) then seqblock
                PushToOutQueue(till, [till, "Successful"])
        endseqblock
        else if(action = CheckBalance) then seqblock
                PushToOutQueue(till, [till, "Report"])
        endseqblock
endpar

rule PassToTill(till, retData) = par
        returnData(till):= retData
endpar



rule UserBehaviour = {
        c := selectClient(self)
        t := selectTill(c)
                if accountStatus(c) = LoggedOut then seqblock
                        if clientAction(c) = EnterPIN then seqblock
                                if RandomVal > 0.2 then seqblock
                                        userInput(c) := CorrectPIN
                                endseqblock
                                else seqblock
                                        userInput(c) := IncorrectPIN
                                endseqblock
                        endseqblock
                        else if clientAction(c) = LogOut then seqblock
                                if RandomVal > 0.8 then seqblock
                                        clientAction(c) := EnterPIN
                                endseqblock
                        endseqblock
                endseqblock
                if accountStatus(c) = LoggedIn then seqblock
                        if tillStatus(t) = InUse then seqblock
                                choose x in [1 .. 4] do
                                        if x = 1 then seqblock
                                                clientAction(c) := CheckBalance
                                                tillStatus(t):= BeginProcessing
                                        endseqblock
                                        else if x = 2 then seqblock
                                                clientAction(c) := Withdraw
                                                tillStatus(t):= BeginProcessing
                                        endseqblock
                                        else if x = 3 then seqblock
                                                clientAction(c) := RequestStatement
                                                tillStatus(t):= BeginProcessing
                                        endseqblock
                                        else if x = 4 then seqblock
                                                clientAction(c) := LogOut
                                        endseqblock
                        endseqblock
                endseqblock
}



rule Observer = {
        forall t in Till do{
                print "=== " + t + ": " + tillStatus(t)
		        print "INQUEUE: " + t + " " + size(INqueue(t))
		        print "OUTQUEUE: " + t + " " + size(OUTqueue(t))
        }
        forall c in Client do{
                print c + " is " + clientAction(c)
        }

}
