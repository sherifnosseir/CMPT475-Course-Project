CoreASM ATM_System

use Standard
use Math
use QueuePlugin

universe ATM = {TillControl, CentralNetwork, CentralDatabase}
universe Till = {Till1, Till2, Till3}
universe Client = { Client1, Client2, Client3}

universe Agents = {ATM_Controller, Network_Controller, user, observer}

enum TillStatus = { Available, InUse, BeginProcessing, Processing }
enum AccountStatus = { LoggedIn, LoggedOut, AccountLocked }
enum UserOperation = { EnterPIN,CheckBalance, Withdraw, RequestStatement, LogOut, Standby}
enum UserInput = { NoInput, CorrectPIN, IncorrectPIN}
//enum DataReturn = { NoData, Unsuccessful, Successful, Report }

function tillStatus: Till -> TillStatus
function accountStatus: Client-> AccountStatus
function clientAction: Client -> UserOperation
function userInput : Client -> UserInput
function selectTill: Client -> Till
function selectClient: Till -> Client
function returnData: Till -> String // Changed from ReturnData
function controlled cardNumber: Till -> String
function controlled pinNumber: till -> String

// Variables
function controlled INqueue: -> LIST
function controlled OUTqueue: -> LIST

// Database Functions
function controlled dbCards: -> MAP
function controlled dbAccounts: -> MAP
function controlled accountMap: till -> MAP
function controlled withdrawMap: till -> MAP

init Main

rule Main = {
        forall t in Till do seqblock
                tillStatus(t) := Available
                returnData(t) := NoData
                if t = Till1 then
                	cardNumber(t) := 1
                else if t = Till2 then
                	cardNumber(t) := 2
                else if t = Till3 then
                	cardNumber(t) := 3
        endseqblock
        forall c in Client do seqblock
                clientAction(c) := LogOut
                accountStatus(c) := LoggedOut
                userInput(c) := NoInput
        endseqblock
        
        seqblock
        
        selectTill(Client1) := Till1
        selectTill(Client2) := Till2
        selectTill(Client3) := Till3
        
        selectClient(Till1) := Client1
        selectClient(Till2) := Client2
        selectClient(Till3) := Client3

        INqueue:=[]
        OUTqueue:=[]
        dbAccounts := { -> }
        add {12345 -> {"pin"-> 123, "address"->"123 homeless street", "balance"->1000, "status"->"LoggedOut"},
        12346 -> {"pin"-> 256, "address"->"123 rich street", "balance"->10000000, "status"->"LoggedOut"},
        12347 -> {"pin"-> 135, "address"->"123 derp street", "balance"->90000000, "status"->"LoggedOut"}} to dbAccounts
        dbCards := { -> }
        add{1 -> 12345, 2 -> 12346, 3 -> 12347} to dbCards
        
        endseqblock
        
        program(self) := undef
        program(ATM_Controller) := @ATMController
        program(Network_Controller) := @NetworkController
        program(user) := @UserBehaviour
        program(observer) := @Observer
}

// Helper Function: Can call this at any point to check client's overall status
rule CheckStatus(Client) =
seqblock
	//forall c in Client do
	//seqblock
	print c + " Status"
	seqblock
		if tillStatus(selectTill(c)) = Available then
			print "Check: TillStatus Available"
		else if tillStatus(selectTill(c)) = InUse then
			print "Check: TillStatus InUse"
		else if tillStatus(selectTill(c)) = BeginProcessing then
			print "Check: TillStatus BeginProcessing"
		else if tillStatus(selectTill(c)) = Processing then
			print "Check: TillStatus Processing"
			
		if accountStatus(c) = LoggedIn then
			print "Check: AccountStatus LoggedIn"
		else if accountStatus(c) = LoggedOut then
			print "Check: AccountStatus LoggedOut"
		else if accountStatus(c) = AccountLocked then
			print "Check: AccountStatus AccountLocked"
			
		if clientAction(c) = EnterPIN then
			print "Check: UserOperation EnterPIN"
		else if clientAction(c) = CheckBalance then
			print "Check: UserOperation CheckBalance"
		else if clientAction(c) = Withdraw then
			print "Check: UserOperation Withdraw"
		else if clientAction(c) = RequestStatement then
			print "Check: UserOperation RequestStatement"
		else if clientAction(c) = LogOut then
			print "Check: UserOperation LogOut"
		else if clientAction(c) = Standby then
			print "Check: UserOperation Standby"	
	//endseqblock
	endseqblock
endseqblock

rule RandomVal =
        return rnd in
        choose x in [1 .. 100] do
                rnd := x/100

rule ATMController = 
	seqblock
        forall c in Client do seqblock
                if clientAction(c) = EnterPIN then seqblock
                		// NOTE: Currently only Client1 does anything!!!!
                        if userInput(c) = CorrectPIN and c = Client1 then seqblock
                        		//print c + " -- userInput = CorrectPIN"
                                accountStatus(c) := LoggedIn
                        endseqblock
                endseqblock

                if(clientAction(c) = LogOut) then seqblock
                		//print c + " -- clientAction = LogOut"
                        tillStatus(selectTill(c)) := Available
                        accountStatus(c) := LoggedOut
                        returnData(selectTill(c)) := NoData
                endseqblock
                else if (accountStatus(c) = LoggedIn and tillStatus(selectTill(c)) = Available) then seqblock
                		//print c + " -- tillStatus = InUse"
                        tillStatus(selectTill(c)) := InUse
                endseqblock
                else if (accountStatus(c) = LoggedIn and tillStatus(selectTill(c)) = BeginProcessing) then seqblock
                        print "***************"+selectTill(c)
                        print "_+_+_+_+_+_+_+_"+clientAction(c)
                        tillStatus(selectTill(c)):= Processing
                        enqueue [selectTill(c), clientAction(c)] into INqueue
                        print "After enqueuing " + size(INqueue)
                endseqblock
        endseqblock

		seqblock
	        forall t in Till do seqblock
	                if (returnData(t)!= undef)then seqblock
	                        print "@@@ " + t + " Result @@@: " + returnData(t)
	                        tillStatus(t):= InUse
	                endseqblock
	        endseqblock
        endseqblock
    
	endseqblock

rule NetworkController = seqblock
    if (size(INqueue) > 0) then seqblock
        print "Dequeuing"
        dequeue nextdbOp from INqueue
        print "After dequeue " + size(INqueue)
        PassToDatabase(head(nextdbOp), head(tail(nextdbOp)))
    endseqblock

    if (size(OUTqueue) > 0) then seqblock
        dequeue nextTillOp from OUTqueue
        PassToTill(head(nextTillOp), head(tail(nextTillOp)))
    endseqblock
endseqblock

rule PassToDatabase(till, action) = seqblock
        if (action = Withdraw) then seqblock
                if RandomVal > 0.0 then seqblock
                		// This needs to happen because for some reason cannot directly modify map value
		        		derp := (dbAccounts()(dbCards()(cardNumber(till))))("balance")
		        		derp := derp - 100
		        		print "TESTIN " + dbAccounts
		        		remove dbCards()(cardNumber(till)) from dbAccounts
		        		add {dbCards()(cardNumber(till)) -> {"pin"-> accountMap(till)("pin"), 
		        			"address"->accountMap(till)("address"), "balance"->derp, "status"->"LoggedOut"}} to dbAccounts
		        		print "TESTIN2 " + dbAccounts
		        		accountMap(till) := dbAccounts()(dbCards()(cardNumber(till)))
                        enqueue [till, ("Successful, new balance " + accountMap(till)("balance"))] into OUTqueue
                endseqblock
                else seqblock
                        enqueue [till, "Unsuccessful"] into OUTqueue
                endseqblock
        endseqblock
        else if(action = RequestStatement) then seqblock
                enqueue [till, "Statement Sent!"] into OUTqueue
        endseqblock
        else if(action = CheckBalance) then seqblock
        		
                enqueue [till, accountMap(till)("balance")] into OUTqueue
        endseqblock
endseqblock

rule PassToTill(till, retData) = seqblock
        returnData(till):= retData
endseqblock



rule UserBehaviour = seqblock
        forall c in Client do seqblock
                if accountStatus(c) = LoggedOut then seqblock
                        if clientAction(c) = EnterPIN then seqblock
                        		//t := selectTill(c)
                        		
                        		// Assume correct input for now
                        		if selectTill(c) = Till1 then
                        			pinNumber(selectTill(c)) := 123
                        		else if selectTill(c) = Till2 then
                        			pinNumber(selectTill(c)) := 256
                        		else if selectTill(c) = Till3 then
                        			pinNumber(selectTill(c)) := 135
                        		
                        		print selectTill(c) + ": inserted pin : " + pinNumber(selectTill(c)) + " for card number " + cardNumber(selectTill(c))
						        accountMap(selectTill(c)) := dbAccounts()(dbCards()(cardNumber(selectTill(c))))
						        print pinNumber(selectTill(c)) + " Card info " + accountMap(selectTill(c))("pin")
						        
                                if pinNumber(selectTill(c)) = accountMap(selectTill(c))("pin") then seqblock
                                        userInput(c) := CorrectPIN
                                        print "CORRECT"
                                endseqblock
                                else seqblock
                                        userInput(c) := IncorrectPIN
                                        print "INCORRECT"
                                endseqblock
                        endseqblock
                        else if clientAction(c) = LogOut then seqblock
                                if RandomVal > 0.0 then seqblock
                                        clientAction(c) := EnterPIN
                                endseqblock
                        endseqblock
                endseqblock
                if accountStatus(c) = LoggedIn then seqblock
                    if tillStatus(selectTill(c)) = InUse then seqblock
                        choose x in [1 .. 4] do seqblock
                            if x = 1 then seqblock
                            		print c + " chose CheckBalance"
                                    clientAction(c) := CheckBalance
                                    tillStatus(selectTill(c)):= BeginProcessing
                                    CheckStatus(c)
                                    print INqueue()
                            endseqblock
                            else if x = 2 then seqblock
                            		print c + " chose Withdraw"
                                    clientAction(c) := Withdraw
                                    tillStatus(selectTill(c)):= BeginProcessing
                                    CheckStatus(c)
                                    print INqueue()
                            endseqblock
                            else if x = 3 then seqblock
                            		print c + " chose RequestStatement"
                                    clientAction(c) := RequestStatement
                                    tillStatus(selectTill(c)):= BeginProcessing
                                    CheckStatus(c)
                                    print INqueue()
                            endseqblock
                            else if x = 4 then seqblock
                                    clientAction(c) := LogOut
                            endseqblock
                        endseqblock
                    endseqblock
                endseqblock
        endseqblock
endseqblock



rule Observer = {
        //forall t in Till do{
        //        print "=== " + t + ": " + tillStatus(t)
        //}
        //forall c in Client do{
        //        print c + " is " + clientAction(c)
        //}
        print "INQUEUE: " + size(INqueue)
        print "OUTQUEUE: "+size(OUTqueue)

}
