CoreASM ATM_System

use Standard
use Math
use QueuePlugin

universe ATM = {TillControl, CentralNetwork, CentralDatabase}
universe Till = {Till1, Till2, Till3}
universe Client = { Client1, Client2, Client3}

universe Agents = {ATM_Controller, Network_Controller, user, observer}

enum TillStatus = { Available, InUse, OutOfOrder }
enum AccountStatus = { LoggedIn, LoggedOut, AccountLocked }
enum UserOperation = { EnterPIN,CheckBalance, Withdraw, RequestStatement, LogOut}
enum UserInput = { NoInput, CorrectPIN, IncorrectPIN}

function tillStatus: Till -> TillStatus
function loginStatus: Client-> AccountStatus
function clientAction: Client -> UserOperation
function userInput : Client -> UserInput

// Variables
function controlled INqueue: -> LIST
function controlled OUTqueue: -> LIST

init Main

rule Main = {
        forall t in Till do{
                tillStatus(t) := Available
        }
        forall c in Client do{
                clientAction(c) := LogOut
                loginStatus(c) := LoggedOut
                userInput(c) := NoInput
        }
        INqueue:=[]
        OUTqueue:=[]



        program(self) := undef
        program(ATM_Controller) := @ATMController
        program(Network_Controller) := @NetworkController
        program(user) := @UserBehaviour
        program(observer) := @Observer

}

rule RandomVal =
        return rnd in
        choose x in [1 .. 100] do
                rnd := x/100

rule ATMController = {
        forall c in Client do{
                if clientAction(c) = EnterPIN then
                        if userInput(c) = CorrectPIN then
                                loginStatus(c) := LoggedIn
        }

        if loginStatus(Client1) = LoggedIn then seqblock
                tillStatus(Till1) := InUse
                enqueue [Till1, clientAction(Client1)] into INqueue
        endseqblock
        else seqblock
                tillStatus(Till1) := Available
        endseqblock

        if loginStatus(Client2) = LoggedIn then seqblock
                tillStatus(Till2) := InUse
                enqueue [Till2, clientAction(Client2)] into INqueue
        endseqblock
        else seqblock
                tillStatus(Till2) := Available
        endseqblock
        if loginStatus(Client3) = LoggedIn then seqblock
                tillStatus(Till3) := InUse
                enqueue [Till3, clientAction(Client3)] into INqueue
        endseqblock
        else seqblock
                tillStatus(Till3) := Available
        endseqblock
}

rule NetworkControll={
		if (size(INqueue) != 0) then
        	

}


rule UserBehaviour = {
        forall c in Client do{
                if loginStatus(c) = LoggedOut then
                        if clientAction(c) = EnterPIN then
                                if RandomVal > 0.2 then
                                        userInput(c) := CorrectPIN
                                else
                                        userInput(c) := IncorrectPIN
                        else if clientAction(c) = LogOut then
                                if RandomVal > 0.8 then
                                        clientAction(c) := EnterPIN
                if loginStatus(c) = LoggedIn then
                        choose x in [1,2,3,4] do
                                if x = 1 then
                                        clientAction(c) := CheckBalance
                                else if x = 2 then
                                        clientAction(c) := Withdraw
                                else if x = 3 then
                                        clientAction(c) := RequestStatement
                                else if x = 4 then{
                                        clientAction(c) := LogOut
                                        loginStatus(c) := LoggedOut
                                }

        }
}



rule Observer = {
        forall t in Till do
                print "=== " + t + ": " + tillStatus(t)

        forall c in Client do
                print c + " is " + clientAction(c)

}